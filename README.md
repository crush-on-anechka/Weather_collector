# Weather collector

Сервис собирает по заданному интервалу информацию о погоде для 50 крупнейших городов мира и сохраняет данные в БД.  

## stack
- [Python]  
- [SQLAlchemy]  
- [PostgreSQL]  
- [Pydantic]  
- [Alembic]  
- [Pytest]  
- [Docker]  

## запуск
- В корневой директории необходимо создать файл `.env` и заполнить его по следующей схеме:  
        - POSTGRES_DB=database_name  
        - POSTGRES_USER=user  
        - POSTGRES_PASSWORD=password  
        - POSTGRES_PORT=port  
        - API_KEY=api_key (генерируется при регистрации на [Openweathermap])

- Приложение запускается в docker-контейнерах. Информация по установке и работе с Docker:  
        - `https://www.docker.com/get-started/`  
- Команда запуска приложения из корневой директории:  
        - `docker-compose up -d`  

## база данных
- Используется реляционная БД PostgreSQL. Таблицы:  
        - cities - информация о городах (страна, координаты)  
        - conditions - схема кодов погодных условий [Openweathermap]  
        - weather_fact - текущие данные о погоде для каждого города  
        - weather_forecast - прогнозные данные о погоде с часовым интервалом на двое суток  

## ограничения
- Сервис зависит от формата данных, в котором API отдает ответ. Так как некоторые значения могут от раза к разу присутстовать или отсутствовать в схеме ответа, программа допускает, что может получить пустые данные. Поэтому, если неполный ответ приходит в связи с изменением схемы API, программа не воспримет это как ошибку. Исключение: одно из полей 'temp', 'temp_min', 'temp_max' должно обязательно присутствовать в ответе. Если ответ приходит, но отсутствуют все три поля с информацией о температуре, мы предполагаем, что логику обработки необходимо пересматривать.  
- Планировщик, обеспечивающий регулярный запуск скрипта, является частью кода, поэтому при аварийной остановке перезапускать сервис придется вручную.  
- Хоть сервис выполняет исключительно IO bound задачи, он синхронный. При сильно возрастающем количестве исходящих запросов придется внедрять асинхронку (при условии что соблюдено ограничение API по частоте/количеству запросов) или рассмотреть платный тариф сервиса API, предлагающий расширенные возможности, в том числе пакетное получение информации.  
- 50 крупнейших городов мира (согласно ТЗ) отобраны вручную и прилагаются к коду в виде json файла. При инициализации сервиса они загружаются в БД и последующее изменение этого списка не предусмотрено. Координаты городов автоматически собираются с [Openweathermap] по названию города. Так как в мире не все города имеют уникальное имя, есть вероятность получить координаты не того населенного пункта, который предполагался. Для списка 50 крупнейших городов эта проблема неактуальна, так как их названия вседа будут в начале списка, даже если в выдаче несколько позиций, но в случае расширения списка городов эти нюансы нужно предусмотреть.  
- Схема кодов погодных условий [Openweathermap] также вручную перенесена в приложенный к коду файл, БД заполняется на его основе. Изменения, если они случатся, нужно мониторить вручную. В защиту этого решения могу сказать, что вряд ли сервис API будет менять у себя эту схему, потому что на ней собраны годы исторических данных.  
- Единицы измерения используются те, которые API отдает по умолчанию, в частности температура воздуха - в кельвинах. Если необходимо использовать другую единицу измерения, логично сразу изменить структуру запроса к API и получать и записывать данные уже в нужных единицах, а не городить потом конвертер при получении данных из БД.  

## примечания
- Задача: получать данные о погоде для управления мощностями дата-центров в плане охлаждения и нагрузки. Предполагаю, что для этих целей помимо текущих показаний важен и прогноз погоды, поэтому я решил собирать прогноз в отдельную таблицу, данные в которой полностью перезаписываются при каждом цикле и соответственно не содержат записи с временной меткой в прошлом.  
- Если мы принимаем, что прогноз погоды для нас важен, вероятно резонно использовать исторические данные о погоде, чтобы примерно понимать погодный режим определенной местности в определенное время года. В таком случае логично было бы предзаполнить базу историческими данными за несколько предыдущих лет, которые также любезно предоставляет сервис [Openweathermap].  
- Из данных, которые предоставляет API, я решил брать почти всю информацию, касающуюся погодных условий. Не знаю, имеют ли значение в целях управления мощностями давление, влажность и структура снега, но во-первых лучше все записывать, чем потом жалеть, а во-вторых, предполагаю, что если на основании исторических записей все-таки будут строиться прогнозы, то эти данные пригодятся для прогнозирования.  

   [Python]: <https://www.python.org>
   [SQLAlchemy]: <https://www.sqlalchemy.org/>
   [PostgreSQL]: <https://www.postgresql.org/>
   [Pydantic]: <https://docs.pydantic.dev/>
   [Alembic]: <https://alembic.sqlalchemy.org/>
   [Pytest]: <https://pytest.org/>
   [Docker]: <https://www.docker.com/>
   [Openweathermap]: <https://openweathermap.org/>
